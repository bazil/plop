//go:build go1.18
// +build go1.18

package cas_test

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"testing"

	"bazil.org/plop/cas"
	"gocloud.dev/blob/memblob"
)

func FuzzRoundtrip(f *testing.F) {
	f.Add([]byte(nil))
	f.Add([]byte(""))
	f.Add([]byte("foo"))
	f.Fuzz(func(t *testing.T, data []byte) {
		b := memblob.OpenBucket(nil)
		s := cas.NewStore("s3kr1t", cas.WithBucket(b))

		ctx := context.Background()
		key, err := s.Create(ctx, bytes.NewReader(data))
		if err != nil {
			panic(fmt.Errorf("create error: %w", err))
		}

		h, err := s.Open(ctx, key)
		if err != nil {
			panic(fmt.Errorf("Open: %v", err))
		}
		if g, e := h.Size(), int64(len(data)); g != e {
			panic(fmt.Errorf("wrong length: %d != %d", g, e))
		}

		r := h.IO(ctx)
		buf, err := io.ReadAll(r)
		if err != nil {
			t.Fatal(fmt.Errorf("Read: %v", err))
		}
		if !bytes.Equal(buf, data) {
			t.Fatal("bad content")
		}
	})
}

func FuzzExtents(f *testing.F) {
	f.Add([]byte(""), int64(10))
	f.Add([]byte{
		// 8 byte end offset, big endian
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
		// 32-byte key
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
	}, int64(3))
	f.Add([]byte{
		// 8 byte end offset, big endian
		0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x10,
		// 32-byte key
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,

		// Repeat per extent
		0x00, 0x00, 0x00, 0x00, 0xB1, 0xC2, 0xD3, 0xE4,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
	}, int64(100))
	f.Add([]byte{
		// 8 byte end offset, big endian
		0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x10,
		// 32-byte key
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
		0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,

		// Repeat per extent
		0x00, 0x00, 0x00, 0x00, 0xB1, 0xC2, 0xD3, 0xE4,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
		0xBA, 0xAD, 0xC0, 0xFF, 0xEE, 0xBA, 0xDB, 0xAD,
	}, int64(0xAFFFFF))
	f.Fuzz(func(t *testing.T, extents []byte, offset int64) {
		ctx := context.Background()
		b := memblob.OpenBucket(nil)
		s := cas.NewStore("s3kr1t", cas.WithBucket(b))
		key, err := s.DebugSaveExtents(ctx, extents)
		if err != nil {
			t.Fatalf("DebugSaveExtents: %v", err)
		}

		h, err := s.Open(ctx, key)
		if err != nil {
			t.Logf("unsurprising Open error: %v", err)
			return
		}
		r := h.IO(ctx)
		buf := make([]byte, 4096)
		if _, err := r.ReadAt(buf, offset); err != nil {
			t.Logf("unsurprising ReadAt error: %v", err)
			return
		}
	})
}
